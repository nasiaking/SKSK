// ===== SKSK v1.0.2 Backend.gs (Final & Truly Complete) =====
const TEMPLATE_ID = '1FgXGKYyiw5ZL1Dft4XyaQ2TEfTH22orDUFTXu5n5gTw';
const USER_PROP_KEY = 'sheetId';
const GEMINI_API_KEY = "AIzaSyDgxghKaLvL4IKyAqjak9up2OPlkXoPJqw"; // Make sure your API Key is pasted here
const MASTER_CACHE_EXPIRATION_SECONDS = 21600;
const CACHE_EXPIRATION_SECONDS = 300;

// ===== Gemini API Functions =====
function callGeminiApi_(prompt) {
  if (GEMINI_API_KEY === "PASTE_YOUR_API_KEY_HERE" || !GEMINI_API_KEY) {
    throw new Error("Gemini API Key has not been set in Backend.gs.");
  }
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
  const payload = { contents: [{ parts: [{ text: prompt }] }] };
  const options = { method: 'post', contentType: 'application/json', payload: JSON.stringify(payload), muteHttpExceptions: true };
  try {
    const response = UrlFetchApp.fetch(apiUrl, options);
    const responseCode = response.getResponseCode();
    const responseBody = response.getContentText();
    if (responseCode !== 200) {
      let errorMessage = `HTTP Error ${responseCode}.`;
      try {
        const errorJson = JSON.parse(responseBody);
        if (errorJson.error && errorJson.error.message) {
          errorMessage += ` Message: ${errorJson.error.message}`;
        }
      } catch (e) { errorMessage += ` Invalid response: ${responseBody}`; }
      console.error("Gemini API Error:", errorMessage);
      throw new Error(errorMessage);
    }
    const result = JSON.parse(responseBody);
    if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
      return result.candidates[0].content.parts[0].text;
    } else {
      console.error("Gemini API response structure is unexpected:", JSON.stringify(result));
      if (result.candidates && result.candidates[0].finishReason === 'SAFETY') {
        throw new Error("Response was blocked for safety reasons.");
      }
      throw new Error("Failed to get a valid response from the AI.");
    }
  } catch (e) {
    console.error("Error in callGeminiApi_:", e.toString());
    throw new Error(`Error contacting the AI service. (${e.message})`);
  }
}

function getFinancialAnalysis(reportData) {
  if (!reportData || reportData.length === 0) return "<p>No data to analyze.</p>";
  const prompt = `You are a friendly and supportive financial advisor. Based on the following expense and budget data in JSON format, provide a brief analysis (max 3 points) in English. Focus on: 1. The largest spending area. 2. Categories where spending exceeded the budget (if any). 3. One practical, actionable tip for saving money. Format your response as HTML with an unordered list (\`<ul>\` and \`<li>\`). Do not use markdown. Data: ${JSON.stringify(reportData)}`;
  return callGeminiApi_(prompt);
}

function getGoalSavingsPlan(goalData) {
  const { goalName, nominalNeeded } = goalData;
  if (!goalName || !nominalNeeded || Number(nominalNeeded) <= 0) return "<p>Goal Name and Nominal Needed are required to create a plan.</p>";
  const prompt = `Create a simple 3-step savings plan to achieve a financial goal named "${goalName}" with a total target of IDR ${Number(nominalNeeded).toLocaleString('id-ID')}. Use English. Assume the user wants to achieve it in a reasonable time (e.g., 6-12 months). Provide the response in HTML format with an unordered list (\`<ul>\` and \`<li>\`). Do not use markdown.`;
  return callGeminiApi_(prompt);
}

// ===== Web App Router =====
function doGet(e) {
  const asset = e && e.parameter && e.parameter.asset || '';
  if (asset === 'manifest') {
    return ContentService.createTextOutput(HtmlService.createHtmlOutputFromFile('manifest').getContent()).setMimeType(ContentService.MimeType.JSON);
  }
  if (asset === 'sw') {
    return ContentService.createTextOutput(HtmlService.createTemplateFromFile('service-worker').getRawContent()).setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  const template = HtmlService.createTemplateFromFile('index');
  return template.evaluate().setTitle('SKSK Finance').setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ===== Database Utilities =====
function getOrCreateDb_() {
  const up = PropertiesService.getUserProperties();
  const id = up.getProperty(USER_PROP_KEY);
  if (!id) throw new Error('Database not connected. Please create a new database first.');
  return SpreadsheetApp.openById(id);
}

function getSheet_(sheetName) {
  const ss = getOrCreateDb_();
  const sh = ss.getSheetByName(sheetName);
  if (!sh) throw new Error(`Sheet not found: ${sheetName}`);
  return sh;
}

function normalizeHeaderName_(s) { return String(s || '').toLowerCase().replace(/[^a-z0-9]+/g, ''); }

function buildHeaderMap_(sheet) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0] || [];
  const map = {};
  headers.forEach((h, i) => map[normalizeHeaderName_(h)] = { index: i, name: h });
  return { headers, map };
}

function getIndex_(map, canonicalKey, tab) {
  const k = normalizeHeaderName_(canonicalKey);
  if (!(k in map)) throw new Error(`Required column not found in '${tab}': ${canonicalKey}`);
  return map[k].index;
}

function assertSchemaV2_(tab, requiredCanonicalKeys) {
  const sh = getSheet_(tab);
  const ctx = buildHeaderMap_(sh);
  const missing = (requiredCanonicalKeys || []).filter(k => !(normalizeHeaderName_(k) in ctx.map));
  if (missing.length) throw new Error(`Schema '${tab}' is missing columns: ${missing.join(', ')}`);
  return { sheet: sh, ...ctx };
}

// ===== Data Filtering & Retrieval =====
function getAllTransactions_() {
  const cache = CacheService.getScriptCache();
  const key = 'tx_all';
  const cached = cache.get(key);
  if (cached) {
    const parsed = JSON.parse(cached);
    parsed.forEach(tx => tx.Date = new Date(tx.Date)); // Re-hydrate dates
    return parsed;
  }

  const req = ['uniqueid', 'date', 'subcategory', 'category', 'wallet', 'amount', 'adjustedamount'];
  const { sheet, map } = assertSchemaV2_('Input', req);
  const vals = sheet.getDataRange().getValues();
  vals.shift(); // remove headers
  const idx = k => getIndex_(map, k, 'Input');
  const result = vals.filter(r => r[idx('uniqueid')]).map(r => ({
    UniqueID: r[idx('uniqueid')], Date: new Date(r[idx('date')]), Subcategory: r[idx('subcategory')],
    Category: r[idx('category')], Wallet: r[idx('wallet')], Amount: r[idx('amount')],
    AdjustedAmount: r[idx('adjustedamount')],
    Note: ('note' in map) ? r[map['note'].index] : '',
    Description: ('description' in map) ? r[map['description'].index] : '',
  }));
  cache.put(key, JSON.stringify(result), CACHE_EXPIRATION_SECONDS);
  return result;
}

function getAvailableYears() {
    const allTx = getAllTransactions_();
    const years = new Set();
    allTx.forEach(tx => {
        if (tx.Date instanceof Date && !isNaN(tx.Date)) {
            years.add(tx.Date.getFullYear());
        }
    });
    const sortedYears = Array.from(years).sort((a, b) => b - a);
    return sortedYears.length > 0 ? sortedYears : [new Date().getFullYear()];
}

function getHistoryTransactions(options = {}) {
    const { year = 'All', month = 'All', page = 1, limit = 50 } = options;
    const allTx = getAllTransactions_();

    const filteredTx = allTx.filter(tx => {
        if (year === 'All') return true;
        const txYear = tx.Date.getFullYear();
        if (txYear != year) return false;
        if (month === 'All') return true;
        const txMonth = tx.Date.getMonth() + 1;
        return txMonth == month;
    });

    filteredTx.sort((a, b) => b.Date - a.Date);

    const startIndex = (page - 1) * limit;
    const paginatedTx = filteredTx.slice(startIndex, startIndex + limit);
    const hasMore = (startIndex + limit) < filteredTx.length;

    return { transactions: paginatedTx, hasMore };
}

function getBudgetSummaryPeriod(options = {}) {
    const { year = 'All', month = 'All' } = options;
    const allTx = getAllTransactions_();
    const cat = assertSchemaV2_('Category Setup', ['subcategory', 'category']);
    const cVals = cat.sheet.getDataRange().getValues(); cVals.shift();
    const c = k => getIndex_(cat.map, k, 'Category Setup');

    const budgetMap = {};
    cVals.forEach(r => {
        const sub = String(r[c('subcategory')] || '').trim(); if (!sub) return;
        const catName = r[c('category')] || '';
        const bIdx = (normalizeHeaderName_('budgetsubcategory') in cat.map) ? cat.map['budgetsubcategory'].index : -1;
        const budget = bIdx >= 0 ? Number(r[bIdx] || 0) : 0;
        budgetMap[sub] = { category: catName, budget };
    });

    const spentBySub = {};
    allTx.forEach(r => {
        if (year !== 'All') {
            if (r.Date.getFullYear() != year) return;
            if (month !== 'All' && (r.Date.getMonth() + 1) != month) return;
        }
        const catName = String(r.Category || '').trim();
        if (catName.toLowerCase() === 'transfer') return;
        const sub = String(r.Subcategory || '').trim();
        if (!sub) return;
        const adj = Number(r.AdjustedAmount || 0);
        if (adj < 0) spentBySub[sub] = (spentBySub[sub] || 0) + adj;
        if (!budgetMap[sub]) budgetMap[sub] = { category: catName || '', budget: 0 };
    });

    const subs = Array.from(new Set([...Object.keys(budgetMap), ...Object.keys(spentBySub)]));
    const rows = subs.map(sub => {
        const info = budgetMap[sub] || { category: '', budget: 0 };
        const spent = Number(spentBySub[sub] || 0);
        return { category: info.category || '', subcategory: sub, spent, budget: Number(info.budget || 0), remaining: Number(info.budget || 0) + spent };
    });
    rows.sort((a, b) => (a.category || '').localeCompare(b.category || '') || a.subcategory.localeCompare(b.subcategory));
    return rows;
}

// ===== Onboarding & Initial Data =====
function createNewDb(){
  const copy = DriveApp.getFileById(TEMPLATE_ID).makeCopy(`SKSK DB - ${new Date().toISOString()}`);
  const ss = SpreadsheetApp.open(copy);
  seedDemo_(ss);
  PropertiesService.getUserProperties().setProperty(USER_PROP_KEY, ss.getId());
  return { ok:true, id:ss.getId(), url: ss.getUrl() };
}

function getDashboardData(){
  const data = {
    wallets: getWallets(),
    categories: getCategories(),
    purposes: getExpensePurposes(),
    notes: getDistinctNotes(25),
    walletBalances: getWalletBalances(),
    budgetSummary: getBudgetSummaryPeriod({ year: new Date().getFullYear(), month: new Date().getMonth() + 1 }),
    availableYears: getAvailableYears(),
    dbUrl: getDbUrl_()
  };
  return data;
}

function getDbUrl_() {
    try {
        const ss = getOrCreateDb_();
        return ss.getUrl();
    } catch (e) {
        return '';
    }
}

function seedDemo_(ss) {
    const now = new Date();
    let sh = ss.getSheetByName('Wallet Setup');
    if (sh) {
        const { headers, map } = buildHeaderMap_(sh);
        if (sh.getLastRow() < 2) {
            const row = {};
            if ('uniqueid' in map) row[map['uniqueid'].name] = Utilities.getUuid();
            if ('wallet' in map) row[map['wallet'].name] = 'Cash';
            if ('wallettype' in map) row[map['wallettype'].name] = 'Cash & Bank';
            if ('walletowner' in map) row[map['walletowner'].name] = 'Owner';
            if ('createdat' in map) row[map['createdat'].name] = now;
            if ('updatedat' in map) row[map['updatedat'].name] = now;
            const arr = headers.map(h => h in row ? row[h] : '');
            sh.appendRow(arr);
        }
    }
    sh = ss.getSheetByName('Category Setup');
    if (sh) {
        const { headers, map } = buildHeaderMap_(sh);
        const vals = sh.getDataRange().getValues(); vals.shift();
        const has = (sub) => vals.some(r => String(r[('subcategory' in map) ? map['subcategory'].index : -1]).trim() === sub);
        const ensure = (sub, type, cat) => {
            if (has(sub)) return;
            const row = {};
            if ('uniqueid' in map) row[map['uniqueid'].name] = Utilities.getUuid();
            if ('transactiontype' in map) row[map['transactiontype'].name] = type;
            if ('category' in map) row[map['category'].name] = cat;
            if ('subcategory' in map) row[map['subcategory'].name] = sub;
            if ('createdat' in map) row[map['createdat'].name] = now;
            if ('updatedat' in map) row[map['updatedat'].name] = now;
            const arr = headers.map(h => h in row ? row[h] : '');
            sh.appendRow(arr);
        };
        ensure('Transfer-Out', 'Transfer', 'Transfer');
        ensure('Transfer-In', 'Transfer', 'Transfer');
    }
}

// ===== Data Manipulation Functions =====

function addTransaction(row) {
    const { sheet: sh, map } = assertSchemaV2_('Input', ['uniqueid', 'date', 'transactiontype', 'wallet', 'category', 'subcategory', 'amount', 'adjustedamount']);
    const now = new Date();
    if (!row.subcategory) throw new Error('Subcategory is required.');
    if (!row.wallet) throw new Error('Wallet is required.');
    const amount = Number(row.amount);
    if (!(amount > 0)) throw new Error('Amount must be greater than 0.');

    const catMap = getCategoryMap_();
    const cinfo = catMap[row.subcategory] || {};
    const subNorm = normalizeHeaderName_(row.subcategory);
    const isTransferOut = (subNorm === 'transferout') || (cinfo.TransactionType === 'Transfer' && !!row.transferTo);

    if (isTransferOut) {
        if (!row.transferTo) throw new Error('"Transfer To" is required for transfers.');
        if (row.transferTo === row.wallet) throw new Error('Destination wallet cannot be the same as source.');
    }

    const txType = (cinfo.TransactionType === 'Transfer') ? 'Transfer' : (cinfo.TransactionType || 'Expense');
    const category = (cinfo.TransactionType === 'Transfer') ? 'Transfer' : (cinfo.Category || '');
    const adjusted = (txType === 'Expense' || isTransferOut) ? -Math.abs(amount) : Math.abs(amount);

    const baseId = Utilities.getUuid();
    const rowData = {
        [map['uniqueid'].name]: baseId,
        [map['date'].name]: row.date ? new Date(row.date) : now,
        [map['transactiontype'].name]: txType,
        [map['wallet'].name]: row.wallet,
        [map['category'].name]: category,
        [map['subcategory'].name]: row.subcategory,
        [map['amount'].name]: amount,
        [map['adjustedamount'].name]: adjusted,
    };
    if ('note' in map) rowData[map['note'].name] = row.note || '';
    if ('description' in map) rowData[map['description'].name] = row.description || '';
    if ('transferto' in map) rowData[map['transferto'].name] = row.transferTo || '';
    if ('expensepurpose' in map) rowData[map['expensepurpose'].name] = row.expensePurpose || '';

    const rowsToWrite = [];
    const headers = Object.values(map).sort((a, b) => a.index - b.index).map(o => o.name);
    rowsToWrite.push(headers.map(h => h in rowData ? rowData[h] : ''));

    if (isTransferOut && row.transferTo) {
        const twin = { ...rowData };
        twin[map['uniqueid'].name] = Utilities.getUuid();
        twin[map['wallet'].name] = row.transferTo;
        twin[map['subcategory'].name] = 'Transfer-In';
        twin[map['adjustedamount'].name] = Math.abs(amount);
        if ('transferto' in map) twin[map['transferto'].name] = row.wallet;
        rowsToWrite.push(headers.map(h => h in twin ? twin[h] : ''));
    }

    if (rowsToWrite.length > 0) {
        sh.getRange(sh.getLastRow() + 1, 1, rowsToWrite.length, headers.length).setValues(rowsToWrite);
    }
    CacheService.getScriptCache().remove('tx_all');
    return { success: true, transaction: rowData };
}

function createWallet(payload) {
    const req = ['wallet'];
    const { map } = assertSchemaV2_('Wallet Setup', req);
    const row = {};
    row[map['wallet'].name] = String(payload.wallet || '').trim();
    if (!row[map['wallet'].name]) throw new Error('Wallet name is required.');
    if ('wallettype' in map) row[map['wallettype'].name] = payload.walletType || 'Cash & Bank';
    if ('walletowner' in map) row[map['walletowner'].name] = payload.walletOwner || 'Owner';
    appendRow_('Wallet Setup', row);
}

function createCategory(payload) {
    const req = ['subcategory', 'category', 'transactiontype'];
    const { map } = assertSchemaV2_('Category Setup', req);
    const row = {};
    row[map['subcategory'].name] = String(payload.subcategory || '').trim();
    row[map['category'].name] = String(payload.category || '').trim();
    row[map['transactiontype'].name] = String(payload.transactionType || '').trim() || 'Expense';
    if (!row[map['subcategory'].name] || !row[map['category'].name]) throw new Error('Subcategory & Category are required.');
    appendRow_('Category Setup', row);
}

function createAccountPurpose(payload) {
    const { map } = assertSchemaV2_('Account Setup', []);
    const key = ('expensepurpose' in map) ? map['expensepurpose'].name : ('expensefor' in map) ? map['expensefor'].name : '';
    if (!key) throw new Error("Column 'Expense Purpose' not found in 'Account Setup'.");
    const val = String(payload.expensePurpose || '').trim();
    if (!val) throw new Error('Expense Purpose is required.');
    const row = {}; row[key] = val;
    appendRow_('Account Setup', row);
}

function createGoal(payload) {
    const { map } = assertSchemaV2_('Goals Setup', []);
    const row = {};
    const nameKey = ('goals' in map) ? map['goals'].name : null;
    if (!nameKey) throw new Error("Column 'Goals' not found in 'Goals Setup'.");
    row[nameKey] = String(payload.goal || '').trim();
    if (!row[nameKey]) throw new Error('Goal name is required.');
    if ('goalowner' in map) row[map['goalowner'].name] = payload.goalOwner || '';
    if ('deadline' in map) row[map['deadline'].name] = payload.deadline ? new Date(payload.deadline) : '';
    if ('nominalneeded' in map) row[map['nominalneeded'].name] = Number(payload.nominalNeeded || 0);
    appendRow_('Goals Setup', row);
}

function getWallets() {
    const { sheet, map } = assertSchemaV2_('Wallet Setup', ['wallet', 'wallettype', 'walletowner']);
    const vals = sheet.getDataRange().getValues(); vals.shift();
    const idx = k => getIndex_(map, k, 'Wallet Setup');
    return vals.filter(r => r[idx('wallet')]).map(r => ({
        Wallet: r[idx('wallet')], WalletType: r[idx('wallettype')], WalletOwner: r[idx('walletowner')]
    }));
}

function getCategories() {
    const { sheet, map } = assertSchemaV2_('Category Setup', ['subcategory', 'category', 'transactiontype']);
    const vals = sheet.getDataRange().getValues(); vals.shift();
    const idx = k => getIndex_(map, k, 'Category Setup');
    return vals.filter(r => String(r[idx('subcategory')] || '').trim()).map(r => ({
        Subcategory: r[idx('subcategory')], Category: r[idx('category')], TransactionType: r[idx('transactiontype')]
    }));
}

function getExpensePurposes() {
    const sh = getSheet_('Account Setup');
    const { headers } = buildHeaderMap_(sh);
    const candidates = ['expensepurpose', 'expensefor'];
    let colIdx = -1;
    headers.forEach((h, i) => { const k = normalizeHeaderName_(h); if (colIdx < 0 && candidates.includes(k)) colIdx = i; });
    if (colIdx < 0) return [];
    const vals = sh.getRange(2, colIdx + 1, Math.max(0, sh.getLastRow() - 1), 1).getValues();
    const seen = new Set(), out = [];
    for (const [v] of vals) { const s = String(v || '').trim(); if (!s || seen.has(s)) continue; seen.add(s); out.push(s); }
    return out;
}

function getDistinctNotes(limit) {
    const LIM = Math.max(1, Number(limit || 20));
    const { sheet, map } = assertSchemaV2_('Input', ['date']);
    if (!('note' in map)) return [];
    const last = sheet.getLastRow(); if (last < 2) return [];
    const start = Math.max(2, last - 800);
    const rng = sheet.getRange(start, 1, last - start + 1, sheet.getLastColumn()).getValues();
    const i = k => getIndex_(map, k, 'Input');
    const rows = rng.map(r => ({ d: new Date(r[i('date')]), n: String(r[map['note']?.index] || '').trim() })).filter(x => x.n);
    rows.sort((a, b) => b.d - a.d);
    const seen = new Set(), out = [];
    for (const x of rows) { if (!seen.has(x.n)) { seen.add(x.n); out.push(x.n); if (out.length >= LIM) break; } }
    return out;
}

function getWalletBalances() {
    const allTx = getAllTransactions_();
    const walMap = getWalletMap_();
    const bal = {};
    allTx.forEach(r => {
        const w = String(r.Wallet || '').trim(); if (!w) return;
        const a = Number(r.AdjustedAmount || 0);
        bal[w] = (bal[w] || 0) + a;
    });
    return Object.keys(walMap).map(w => ({
        wallet: w,
        type: (walMap[w] && walMap[w].WalletType) ? walMap[w].WalletType : 'Other Asset',
        balance: Number(bal[w] || 0)
    }));
}

function getGoalsWithProgress_() {
    const allTx = getAllTransactions_();
    const balanceByWallet = {};
    allTx.forEach(r => {
        const w = r.Wallet; if (!w) return;
        const a = Number(r.AdjustedAmount || 0);
        balanceByWallet[w] = (balanceByWallet[w] || 0) + a;
    });
    const goals = assertSchemaV2_('Goals Setup', ['goals']);
    const gVals = goals.sheet.getDataRange().getValues(); gVals.shift();
    const g = k => getIndex_(goals.map, k, 'Goals Setup');
    const hasNeeded = ('nominalneeded' in goals.map);
    const hasOwner = ('goalowner' in goals.map);
    const rows = [];
    gVals.forEach(r => {
        const goalName = String(r[g('goals')] || '').trim(); if (!goalName) return;
        const needed = hasNeeded ? Number(r[g('nominalneeded')] || 0) : 0;
        const progress = Number(balanceByWallet[goalName] || 0);
        const completion = needed > 0 ? (progress / needed) : 0;
        rows.push({ goal: goalName, owner: hasOwner ? r[g('goalowner')] : '', needed, progress, completion });
    });
    return rows;
}

function getCategoryMap_(){
  const cache = CacheService.getScriptCache();
  const key = 'map_categories';
  const hit = cache.get(key); if (hit) return JSON.parse(hit);
  const sh = getSheet_('Category Setup');
  const { map } = buildHeaderMap_(sh);
  const vals = sh.getDataRange().getValues(); vals.shift();
  const idx = k => getIndex_(map,k,'Category Setup');
  const m = {};
  vals.forEach(r=>{
    const sub = String(r[idx('subcategory')] || '').trim();
    if (!sub) return;
    m[sub] = { TransactionType: r[idx('transactiontype')], Category: r[idx('category')] };
  });
  cache.put(key, JSON.stringify(m), MASTER_CACHE_EXPIRATION_SECONDS);
  return m;
}

function getWalletMap_(){
  const cache = CacheService.getScriptCache();
  const key = 'map_wallets';
  const hit = cache.get(key); if (hit) return JSON.parse(hit);
  const sh = getSheet_('Wallet Setup');
  const { map } = buildHeaderMap_(sh);
  const vals = sh.getDataRange().getValues(); vals.shift();
  const idx = k => getIndex_(map,k,'Wallet Setup');
  const m = {};
  vals.forEach(r=>{
    const w = String(r[idx('wallet')] || '').trim();
    if (!w) return;
    m[w] = { WalletOwner: r[idx('walletowner')], WalletType: r[idx('wallettype')] };
  });
  cache.put(key, JSON.stringify(m), MASTER_CACHE_EXPIRATION_SECONDS);
  return m;
}
