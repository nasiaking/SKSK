// ===== SKSK v0.7.4 Backend.gs (Optimized with Caching) =====
const TEMPLATE_ID = '1FgXgKYyiw5ZL1Dft4XyaQ2TEfTH22orDUFTXu5n5gTw';
const USER_PROP_KEY = 'sheetId';
const SCHEMA_VARIANT_KEY = 'SCHEMA_VARIANT';
const IDEMP_SCAN_ROWS = 50;
const CACHE_EXPIRATION_SECONDS = 300;
const MASTER_CACHE_EXPIRATION_SECONDS = 1800;

// ===== Util Cache =====
function clearCacheByPrefix(prefix) {
  const cache = CacheService.getScriptCache();
  const keys = ['report_budget', 'report_goals', 'tx_list', 'wallet_balances'];
  cache.removeAll(keys);
  console.log('Report caches cleared due to data change.');
}

// ===== Router Web App & Assets PWA =====
function doGet(e) {
  const asset = e && e.parameter && e.parameter.asset || '';
  if (asset === 'manifest') {
    return ContentService.createTextOutput(HtmlService.createHtmlOutputFromFile('manifest').getContent())
      .setMimeType(ContentService.MimeType.JSON);
  }
  if (asset === 'sw') {
    return ContentService.createTextOutput(
      HtmlService.createTemplateFromFile('service-worker').getRawContent()
    ).setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return HtmlService.createTemplateFromFile('index').evaluate().setTitle('SKSK').setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ===== Util DB =====
function getOrCreateDb_() {
  const up = PropertiesService.getUserProperties();
  const id = up.getProperty(USER_PROP_KEY);
  if (!id) throw new Error('Database belum terhubung. Silakan buat DB terlebih dahulu.');
  return SpreadsheetApp.openById(id);
}
function getSheet_(sheetName) {
  const ss = getOrCreateDb_();
  const sh = ss.getSheetByName(sheetName);
  if (!sh) throw new Error(`Sheet tidak ditemukan: ${sheetName}`);
  return sh;
}

// ===== Header Helpers =====
function normalizeHeaderName_(s){ return String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,''); }
function buildHeaderMap_(sheet){
  const headers = sheet.getRange(1,1,1,sheet.getLastColumn()).getValues()[0] || [];
  const map = {};
  headers.forEach((h,i)=> map[normalizeHeaderName_(h)] = { index:i, name:h });
  return { headers, map };
}
function getIndex_(map, canonicalKey, tab){
  const k = normalizeHeaderName_(canonicalKey);
  if (!(k in map)) throw new Error(`Kolom wajib tidak ditemukan di '${tab}': ${canonicalKey}`);
  return map[k].index;
}
function assertSchemaV2_(tab, requiredCanonicalKeys){
  const sh = getSheet_(tab);
  const ctx = buildHeaderMap_(sh);
  const missing = (requiredCanonicalKeys||[]).filter(k => !(normalizeHeaderName_(k) in ctx.map));
  if (missing.length) throw new Error(`Skema '${tab}' kurang kolom: ${missing.join(', ')}`);
  return { sheet: sh, ...ctx };
}

// ===== Onboarding =====
function createNewDb(){
  const copy = DriveApp.getFileById(TEMPLATE_ID).makeCopy(`SKSK DB - ${new Date().toISOString()}`);
  const ss = SpreadsheetApp.open(copy);
  seedDemo_(ss);
  PropertiesService.getUserProperties().setProperty(USER_PROP_KEY, ss.getId());
  detectSchemaVariant_();
  return { ok:true, id:ss.getId(), url:`https://docs.google.com/spreadsheets/d/${ss.getId()}/edit` };
}
function detectSchemaVariant_(){
  try {
    const sh = getSheet_('Input');
    const { map } = buildHeaderMap_(sh);
    const variant = ('createdat' in map || 'transactiontype' in map) ? 'CANONICAL' : 'LEGACY';
    PropertiesService.getUserProperties().setProperty(SCHEMA_VARIANT_KEY, variant);
  } catch(e){}
}
function seedDemo_(ss){
  const now = new Date();
  let sh = ss.getSheetByName('Wallet Setup');
  if (sh) {
    const { headers, map } = buildHeaderMap_(sh);
    const last = sh.getLastRow();
    if (last < 2) {
      const row = {};
      if ('uniqueid' in map) row[map['uniqueid'].name] = Utilities.getUuid();
      if ('wallet' in map) row[map['wallet'].name] = 'Cash';
      if ('wallettype' in map) row[map['wallettype'].name] = 'Personal';
      if ('walletowner' in map) row[map['walletowner'].name] = 'Owner';
      if ('createdat' in map) row[map['createdat'].name] = now;
      if ('updatedat' in map) row[map['updatedat'].name] = now;
      const arr = headers.map(h => h in row ? row[h] : '');
      sh.getRange(sh.getLastRow()+1,1,1,headers.length).setValues([arr]);
    }
  }
  sh = ss.getSheetByName('Category Setup');
  if (sh) {
    const { headers, map } = buildHeaderMap_(sh);
    const vals = sh.getDataRange().getValues(); vals.shift();
    const has = (sub) => vals.some(r => String(r[('subcategory' in map)? map['subcategory'].index : -1]).trim() === sub);
    const ensure = (sub) => {
      const row = {};
      if ('uniqueid' in map) row[map['uniqueid'].name] = Utilities.getUuid();
      if ('transactiontype' in map) row[map['transactiontype'].name] = 'Transfer';
      if ('category' in map) row[map['category'].name] = 'Transfer';
      if ('subcategory' in map) row[map['subcategory'].name] = sub;
      if ('createdat' in map) row[map['createdat'].name] = now;
      if ('updatedat' in map) row[map['updatedat'].name] = now;
      const arr = headers.map(h => h in row ? row[h] : '');
      sh.getRange(sh.getLastRow()+1,1,1,headers.length).setValues([arr]);
    };
    if (!has('Transfer-Out')) ensure('Transfer-Out');
    if (!has('Transfer-In')) ensure('Transfer-In');
  }
}

// ===== Append Row =====
function appendRow_(tab, rowObj){
  const { sheet, headers, map } = assertSchemaV2_(tab, []);
  const now = new Date();
  if ('updatedat' in map && !('updatedat' in rowObj)) rowObj[map['updatedat'].name] = now;
  if ('createdat' in map && !('createdat' in rowObj)) rowObj[map['createdat'].name] = now;
  if ('uniqueid'  in map && !('uniqueid'  in rowObj)) rowObj[map['uniqueid'].name]  = Utilities.getUuid();
  const ordered = headers.map(h => (h in rowObj ? rowObj[h] : ''));
  sheet.getRange(sheet.getLastRow()+1,1,1,headers.length).setValues([ordered]);

  const cache = CacheService.getScriptCache();
  if (tab === 'Wallet Setup') cache.remove('master_wallets');
  if (tab === 'Category Setup') cache.remove('master_categories');
  if (tab === 'Account Setup') cache.remove('master_purposes');
  if (tab === 'Goals Setup') cache.remove('report_goals');
  return { ok:true };
}

// ===== Setup Creators =====
function createWallet(payload){
  const req = ['wallet'];
  const { map } = assertSchemaV2_('Wallet Setup', req);
  const row = {};
  row[map['wallet'].name] = String(payload.wallet || '').trim();
  if (!row[map['wallet'].name]) throw new Error('Nama Wallet wajib diisi.');
  if ('wallettype' in map)   row[map['wallettype'].name]   = payload.walletType || 'Personal';
  if ('walletowner' in map)  row[map['walletowner'].name]  = payload.walletOwner || 'Owner';
  return appendRow_('Wallet Setup', row);
}
function createCategory(payload){
  const req = ['subcategory','category','transactiontype'];
  const { map } = assertSchemaV2_('Category Setup', req);
  const row = {};
  row[map['subcategory'].name]     = String(payload.subcategory || '').trim();
  row[map['category'].name]        = String(payload.category || '').trim();
  row[map['transactiontype'].name] = String(payload.transactionType || '').trim() || 'Expense';
  if (!row[map['subcategory'].name] || !row[map['category'].name]) throw new Error('Subcategory & Category wajib.');
  return appendRow_('Category Setup', row);
}
function createAccountPurpose(payload){
  const { map } = assertSchemaV2_('Account Setup', []);
  const key = ('expensepurpose' in map) ? map['expensepurpose'].name
            : ('expensefor' in map)     ? map['expensefor'].name : '';
  if (!key) throw new Error("Kolom 'Expense Purpose' tidak ditemukan di 'Account Setup'.");
  const val = String(payload.expensePurpose || '').trim();
  if (!val) throw new Error('Expense Purpose wajib diisi.');
  const row = {}; row[key] = val;
  return appendRow_('Account Setup', row);
}
function createGoal(payload){
  const { map } = assertSchemaV2_('Goals Setup', []);
  const row = {};
  const nameKey = ('goals' in map) ? map['goals'].name : null;
  if (!nameKey) throw new Error("Kolom 'Goals' tidak ditemukan di 'Goals Setup'.");
  row[nameKey] = String(payload.goal || '').trim();
  if (!row[nameKey]) throw new Error('Nama Goal wajib diisi.');
  if ('goalowner' in map)     row[map['goalowner'].name]     = payload.goalOwner || '';
  if ('deadline' in map)      row[map['deadline'].name]      = payload.deadline ? new Date(payload.deadline) : '';
  if ('nominalneeded' in map) row[map['nominalneeded'].name] = Number(payload.nominalNeeded || 0);
  return appendRow_('Goals Setup', row);
}

// ===== Cached Maps =====
function getCategoryMap_(){
  const cache = CacheService.getScriptCache();
  const key = 'map_categories';
  const hit = cache.get(key); if (hit) return JSON.parse(hit);
  const sh = getSheet_('Category Setup');
  const { map } = buildHeaderMap_(sh);
  const vals = sh.getDataRange().getValues(); vals.shift();
  const idx = k => getIndex_(map,k,'Category Setup');
  const m = {};
  vals.forEach(r=>{
    const sub = String(r[idx('subcategory')] || '').trim();
    if (!sub) return;
    m[sub] = { TransactionType: r[idx('transactiontype')], Category: r[idx('category')],
               Ratios: (normalizeHeaderName_('ratios') in map) ? r[map['ratios'].index] : '' };
  });
  cache.put(key, JSON.stringify(m), MASTER_CACHE_EXPIRATION_SECONDS);
  return m;
}
function getWalletMap_(){
  const cache = CacheService.getScriptCache();
  const key = 'map_wallets';
  const hit = cache.get(key); if (hit) return JSON.parse(hit);
  const sh = getSheet_('Wallet Setup');
  const { map } = buildHeaderMap_(sh);
  const vals = sh.getDataRange().getValues(); vals.shift();
  const idx = k => getIndex_(map,k,'Wallet Setup');
  const m = {};
  vals.forEach(r=>{
    const w = String(r[idx('wallet')] || '').trim();
    if (!w) return;
    m[w] = { WalletOwner: r[idx('walletowner')], WalletType: r[idx('wallettype')] };
  });
  cache.put(key, JSON.stringify(m), MASTER_CACHE_EXPIRATION_SECONDS);
  return m;
}

// ===== Getters (Public, Cached) =====
function getWallets(){
  const cache = CacheService.getScriptCache();
  const key = 'master_wallets';
  const cached = cache.get(key); if (cached) return JSON.parse(cached);
  const { sheet, map } = assertSchemaV2_('Wallet Setup', ['wallet','wallettype','walletowner']);
  const vals = sheet.getDataRange().getValues(); vals.shift();
  const idx = k => getIndex_(map,k,'Wallet Setup');
  const result = vals.filter(r=>r[idx('wallet')]).map(r=>({
    UniqueID: ('uniqueid' in map) ? r[map['uniqueid'].index] : '',
    Wallet: r[idx('wallet')], WalletType: r[idx('wallettype')], WalletOwner: r[idx('walletowner')],
  }));
  cache.put(key, JSON.stringify(result), MASTER_CACHE_EXPIRATION_SECONDS);
  return result;
}
function getCategories(){
  const cache = CacheService.getScriptCache();
  const key = 'master_categories';
  const cached = cache.get(key); if (cached) return JSON.parse(cached);
  const { sheet, map } = assertSchemaV2_('Category Setup', ['subcategory','category','transactiontype']);
  const vals = sheet.getDataRange().getValues(); vals.shift();
  const idx = k => getIndex_(map,k,'Category Setup');
  const result = vals.filter(r => String(r[idx('subcategory')]||'').trim()).map(r=>({
    Subcategory: r[idx('subcategory')], Category: r[idx('category')], TransactionType: r[idx('transactiontype')],
    Ratios: (normalizeHeaderName_('ratios') in map) ? r[map['ratios'].index] : '',
  }));
  cache.put(key, JSON.stringify(result), MASTER_CACHE_EXPIRATION_SECONDS);
  return result;
}
function getTransactions(){
  const cache = CacheService.getScriptCache();
  const key = 'tx_list';
  const cached = cache.get(key); if (cached) return JSON.parse(cached);
  const req = ['uniqueid','date','subcategory','category','wallet','amount','adjustedamount'];
  const { sheet, map } = assertSchemaV2_('Input', req);
  const vals = sheet.getDataRange().getValues(); vals.shift();
  const idx = k => getIndex_(map,k,'Input');
  const result = vals.filter(r=>r[idx('uniqueid')]).map(r=>({
    UniqueID: r[idx('uniqueid')], Date: r[idx('date')], Subcategory: r[idx('subcategory')],
    Category: r[idx('category')], Wallet: r[idx('wallet')], Amount: r[idx('amount')],
    AdjustedAmount: r[idx('adjustedamount')],
    Note: ('note' in map) ? r[map['note'].index] : '',
    Description: ('description' in map) ? r[map['description'].index] : '',
  }));
  cache.put(key, JSON.stringify(result), CACHE_EXPIRATION_SECONDS);
  return result;
}
function getDistinctNotes(limit){
  const LIM = Math.max(1, Number(limit || 20));
  const { sheet, map } = assertSchemaV2_('Input', ['date']);
  if (!('note' in map)) return [];
  const last = sheet.getLastRow(); if (last < 2) return [];
  const start = Math.max(2, last - 800);
  const rng = sheet.getRange(start,1,last-start+1,sheet.getLastColumn()).getValues();
  const i = k => getIndex_(map,k,'Input');
  const rows = rng.map(r => ({ d:new Date(r[i('date')]), n:String(r[map['note'].index]||'').trim() })).filter(x=>x.n);
  rows.sort((a,b)=> b.d - a.d);
  const seen = new Set(), out = [];
  for (const x of rows){ if (!seen.has(x.n)){ seen.add(x.n); out.push(x.n); if (out.length>=LIM) break; } }
  return out;
}
function getExpensePurposes(limit){
  const cache = CacheService.getScriptCache();
  const key = 'master_purposes';
  const cached = cache.get(key); if (cached) return JSON.parse(cached);
  const LIM = Math.max(1, Number(limit || 100));
  const sh = getSheet_('Account Setup');
  const { headers } = buildHeaderMap_(sh);
  const candidates = ['expensepurpose','expensefor'];
  let colIdx = -1;
  headers.forEach((h,i)=>{ const k = normalizeHeaderName_(h); if (colIdx<0 && candidates.includes(k)) colIdx=i; });
  if (colIdx<0) return [];
  const vals = sh.getRange(2,colIdx+1,Math.max(0, sh.getLastRow()-1),1).getValues();
  const seen = new Set(), out = [];
  for (const [v] of vals){ const s = String(v||'').trim(); if (!s || seen.has(s)) continue; seen.add(s); out.push(s); if (out.length>=LIM) break; }
  cache.put(key, JSON.stringify(out), MASTER_CACHE_EXPIRATION_SECONDS);
  return out;
}

// ===== Add Transaction =====
function addTransaction(row){
  try{
    const { sheet: sh, map } = assertSchemaV2_('Input',
      ['uniqueid','date','transactiontype','wallet','category','subcategory','amount','adjustedamount']);
    const now = new Date();
    if (!row.subcategory) throw new Error('Subcategory wajib diisi.');
    if (!row.wallet) throw new Error('Wallet wajib diisi.');
    const amount = Number(row.amount);
    if (!(amount > 0)) throw new Error('Amount harus > 0.');

    const catMap = getCategoryMap_();
    const cinfo = catMap[row.subcategory] || {};
    const subNorm = normalizeHeaderName_(row.subcategory);
    const isTransferType = (cinfo.TransactionType === 'Transfer') || (subNorm === 'transferout' || subNorm === 'transferin');
    const isTransferOut  = (subNorm === 'transferout') || (isTransferType && !!row.transferTo);
    const isTransferIn   = (subNorm === 'transferin');

    if (isTransferOut) {
      if (!row.transferTo) throw new Error('Transfer To wajib diisi untuk Transfer-Out.');
      if (row.transferTo === row.wallet) throw new Error('Dompet tujuan tidak boleh sama.');
    }

    const txType   = isTransferType ? 'Transfer' : (cinfo.TransactionType || 'Expense');
    const category = isTransferType ? 'Transfer' : (cinfo.Category || '');
    const adjusted = isTransferOut ? -Math.abs(amount)
                   : isTransferIn  ?  Math.abs(amount)
                   : (txType === 'Expense') ? -Math.abs(amount) : Math.abs(amount);

    const baseId = Utilities.getUuid();
    const idOut  = baseId + '_out';
    const idIn   = baseId + '_in';

    const rowData = {
      [map['uniqueid'].name]: isTransferOut ? idOut : baseId,
      [map['date'].name]: row.date ? new Date(row.date) : now,
      [map['transactiontype'].name]: txType,
      [map['wallet'].name]: row.wallet,
      [map['category'].name]: category,
      [map['subcategory'].name]: row.subcategory,
      [map['amount'].name]: amount,
      [map['adjustedamount'].name]: adjusted,
    };
    if ('note' in map)           rowData[map['note'].name] = row.note || '';
    if ('description' in map)    rowData[map['description'].name] = row.description || '';
    if ('transferto' in map)     rowData[map['transferto'].name] = row.transferTo || '';
    if ('expensepurpose' in map) rowData[map['expensepurpose'].name] = row.expensePurpose || '';

    const rowsToWrite = [];
    const headers = Object.values(map).sort((a,b)=>a.index-b.index).map(o=>o.name);
    rowsToWrite.push(headers.map(h => h in rowData ? rowData[h] : ''));

    if (isTransferOut && row.transferTo) {
      const twin = { ...rowData };
      twin[map['uniqueid'].name]        = idIn;
      twin[map['wallet'].name]          = row.transferTo;
      twin[map['subcategory'].name]     = 'Transfer-In';
      twin[map['adjustedamount'].name]  = Math.abs(amount);
      if ('transferto' in map) twin[map['transferto'].name] = row.wallet;
      rowsToWrite.push(headers.map(h => h in twin ? twin[h] : ''));
    }

    if (rowsToWrite.length > 0) {
      sh.getRange(sh.getLastRow()+1,1,rowsToWrite.length,headers.length).setValues(rowsToWrite);
    }
    clearCacheByPrefix('report_');
    return { success:true, id:baseId };
  } catch(err){ throw err; }
}

// ===== Reports =====
  function getBudgetSummary(){
    const cache = CacheService.getScriptCache();
    const key = 'report_budget';
    const cached = cache.get(key); if (cached) return JSON.parse(cached);

    const cat = assertSchemaV2_('Category Setup', ['subcategory','category']);
    const inp = assertSchemaV2_('Input', ['subcategory','category','adjustedamount']);

    const cVals = cat.sheet.getDataRange().getValues(); cVals.shift();
    const iVals = inp.sheet.getDataRange().getValues(); iVals.shift();
    const c = k => getIndex_(cat.map,k,'Category Setup');
    const i = k => getIndex_(inp.map,k,'Input');

    // 1) daftar budget per sub, tetapi SKIP category Transfer
    const budgetMap = {};
    cVals.forEach(r=>{
      const sub = String(r[c('subcategory')]||'').trim(); if (!sub) return;
      const catName = String(r[c('category')]||'').trim();
      if (catName.toLowerCase() === 'transfer') return; // ← abaikan transfer
      const bIdx = (normalizeHeaderName_('budgetsubcategory') in cat.map) ? cat.map['budgetsubcategory'].index : -1;
      const budget = bIdx >= 0 ? Number(r[bIdx] || 0) : 0;
      budgetMap[sub] = { category: catName, budget };
    });

    // 2) akumulasi spent (negatif) per sub, SKIP baris input dengan category Transfer
    const spentBySub = {};
    iVals.forEach(r=>{
      const sub = String(r[i('subcategory')]||'').trim(); if (!sub) return;
      const catName = String(r[i('category')]||'').trim();
      if (catName.toLowerCase() === 'transfer') return; // ← abaikan transfer
      const adj = Number(r[i('adjustedamount')] || 0);
      if (adj < 0) spentBySub[sub] = (spentBySub[sub] || 0) + adj;
      if (!budgetMap[sub]) budgetMap[sub] = { category: catName || '', budget: 0 };
    });

    const subs = Array.from(new Set([...Object.keys(budgetMap), ...Object.keys(spentBySub)]));
    const rows = subs.map(sub=>{
      const info = budgetMap[sub] || { category:'', budget:0 };
      const spent = Number(spentBySub[sub] || 0); // negatif
      return {
        category: info.category || '',
        subcategory: sub,
        spent,
        budget: Number(info.budget || 0),
        remaining: Number(info.budget || 0) + spent
      };
    });

    // urutkan biar rapi
    rows.sort((a,b)=> (a.category||'').localeCompare(b.category||'') || a.subcategory.localeCompare(b.subcategory));
    cache.put(key, JSON.stringify(rows), CACHE_EXPIRATION_SECONDS);
    return rows;
  }


// NEW: Wallet Balances (untuk Dashboard)
function getWalletBalances(){
  const cache = CacheService.getScriptCache();
  const key = 'wallet_balances';
  const cached = cache.get(key); if (cached) return JSON.parse(cached);

  const inp = assertSchemaV2_('Input', ['wallet','adjustedamount']);
  const iVals = inp.sheet.getDataRange().getValues(); iVals.shift();
  const i = k => getIndex_(inp.map,k,'Input');

  const walMap = getWalletMap_(); // ambil tipe wallet
  const bal = {};
  iVals.forEach(r=>{
    const w = String(r[i('wallet')]||'').trim(); if (!w) return;
    const a = Number(r[i('adjustedamount')] || 0);
    bal[w] = (bal[w] || 0) + a;
  });

  const rows = Object.keys(walMap).map(w => ({
    wallet: w,
    type: walMap[w].WalletType || '',
    balance: Number(bal[w] || 0)
  }));
  cache.put(key, JSON.stringify(rows), CACHE_EXPIRATION_SECONDS);
  return rows;
}

function getGoalsWithProgress(){
  const cache = CacheService.getScriptCache();
  const key = 'report_goals';
  const cached = cache.get(key); if (cached) return JSON.parse(cached);

  const inp = assertSchemaV2_('Input', ['wallet','adjustedamount']);
  const iVals = inp.sheet.getDataRange().getValues(); iVals.shift();
  const i = k => getIndex_(inp.map,k,'Input');

  const balanceByWallet = {};
  iVals.forEach(r=>{
    const w = r[i('wallet')]; if (!w) return;
    const a = Number(r[i('adjustedamount')] || 0);
    balanceByWallet[w] = (balanceByWallet[w] || 0) + a;
  });

  const goals = assertSchemaV2_('Goals Setup', ['goals']);
  const gVals = goals.sheet.getDataRange().getValues(); gVals.shift();
  const g = k => getIndex_(goals.map,k,'Goals Setup');
  const hasNeeded = ('nominalneeded' in goals.map);
  const hasOwner  = ('goalowner' in goals.map);

  const rows = [];
  gVals.forEach(r=>{
    const goalName = String(r[g('goals')]||'').trim(); if (!goalName) return;
    const needed   = hasNeeded ? Number(r[g('nominalneeded')] || 0) : 0;
    const progress = Number(balanceByWallet[goalName] || 0);
    const completion = needed > 0 ? (progress / needed) : 0;
    rows.push({ goal:goalName, owner: hasOwner ? r[g('goalowner')] : '', needed, progress, completion });
  });

  cache.put(key, JSON.stringify(rows), CACHE_EXPIRATION_SECONDS);
  return rows;
}

// ===== Initial Aggregation =====
function getInitialData(){
  return {
    wallets: getWallets(),
    categories: getCategories(),
    transactions: getTransactions(),
    notes: getDistinctNotes(25),
    purposes: getExpensePurposes(200),
    budgetSummary: getBudgetSummary(),
    goalsProgress: getGoalsWithProgress(),
    walletBalances: getWalletBalances()
  };
}
